# J'y pip rien

La gestion des paquets python avec pip a un désavantage, **la maintenance dans le temps**.

Le mélange *pip et virtualenv* est un apport pour gérer ses développements. La gestion de l'installation des paquets et de leurs dépendances ainsi que la désinstallation[^1] sont bien faites.

Par contre lorsque vous reprenez un projet, il est difficile de discerner quels paquets sont encore utilisés et ceux installés comme dépendances.

## Les limites des fichiers *requirements*

Avoir un fichier *requirements.txt* pour la production et *dev-requirements.txt* pour le développement c'est pratique. Vous installez un paquet puis générez vos fichiers *requirements*.

Prenons un exemple d'un projet Django avec le paquet *django-debug-toolbar*.

Au départ votre projet ne contient pas de paquets spécifiques pour lui.
```shell
(article_pip) [ioo@shikoku ~]$ pip freeze
```
Installons *Django* :
```shell
(article_pip) [ioo@shikoku ~]$ pip install Django
Collecting Django
  Using cached Django-1.9.6-py2.py3-none-any.whl
Installing collected packages: Django
Successfully installed Django-1.9.6
```
```shell
(article_pip) [ioo@shikoku ~]$ pip freeze
Django==1.9.6
```
Installons *django-debug-toolbar* :
```shell
(article_pip) [ioo@shikoku ~]$ pip install django-debug-toolbar
Collecting django-debug-toolbar
  Using cached django_debug_toolbar-1.4-py2.py3-none-any.whl
Requirement already satisfied (use --upgrade to upgrade): Django>=1.7 in ./.virtualenv/article_pip/lib/python3.5/site-packages (from django-debug-toolbar)
Collecting sqlparse (from django-debug-toolbar)
Installing collected packages: sqlparse, django-debug-toolbar
Successfully installed django-debug-toolbar-1.4 sqlparse-0.1.19
```
```shell
(article_pip) [ioo@shikoku ~]$ pip freeze
Django==1.9.6
django-debug-toolbar==1.4
sqlparse==0.1.19
```
À ce stade vous êtes capable de maintenir parfaitement vos fichiers *requirements*.
```
# requirements.txt
Django==1.9.6
```
```
# dev-requirements.txt
Django==1.9.6
django-debug-toolbar==1.4
sqlparse==0.1.19
```
Le problème c'est lorsque vous revenez quelques temps après sur votre projet. Faites un *pip freeze*. Vous savez à quoi servent les paquets *Django* et *django-debug-toolbar*. Mais *sqlparse* ? Un oubli dans le *requirements.txt* ? Un ajout par un autre développeur ?

Imaginez également que dans votre projet vous ayez désinstallé le paquet *django-debug-toolbar*, la dépendance reste présente.
```shell
(article_pip) [ioo@shikoku ~]$ pip freeze
Django==1.9.6
sqlparse==0.1.19
```
Autant pour vos paquets sur votre poste de développement je peux faire une exception, mais pour vos paquets en production, à moins d'être devOps, un administrateur système vous maudira.

Quelques raisons :
* Peut faire l'objet d'un [WAt](https://www.destroyallsoftware.com/talks/wat).
* des paquets inutiles
* forcer une version pour une dépendance
* distinction paquets de dev/prod
* des erreurs pour paquet manquant

## pip-tools à la rescousse.

Vous aurez compris que cette situation ne me plaît guère, la solution provient de [pip-tools](https://github.com/nvie/pip-tools). Je vous laisse découvrir la beauté de la chose par la [documentation du projet](https://github.com/nvie/pip-tools/blob/master/README.md) ainsi que par [un article](http://nvie.com/posts/better-package-management/) qui vous donnent plus d'éléments. Je vous décris simplement mon utilisation en reprenant l'exemple précédent.

Vous installez, *pip-tools*, *Django* et *django-debug-toolbar*.
Vous créez votre fichier pour le développement *dev-requirements.in* et un pour la production *requirements.in*.
```
# dev-requirements.in
pip-tools
Django
django-debug-toolbar
```
La commande pip-compile permet de générer le fichier *dev-requirements.txt* correspondant.
```
(article_pip) [ioo@shikoku ~]$ pip-compile dev-requirements.in
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile --output-file dev-requirements.txt dev-requirements.in
#
click==6.6                # via pip-tools
django-debug-toolbar==1.4
Django==1.9.6             # via django-debug-toolbar
first==2.0.1              # via pip-tools
pip-tools==1.6.5
six==1.10.0               # via pip-tools
sqlparse==0.1.19          # via django-debug-toolbar

```
```
#requirements.in
Django
```
On utilise à nouveau *pip-compile* pour générer le fichier *requirements.txt*
```
(article_pip) [ioo@shikoku ~]$ pip-compile
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile --output-file requirements.txt requirements.in
#
Django==1.9.6
```

La commande *pip-sync* permet d'installer les paquets, mais surtout son avantage est à la désinstallation. Supprimons la *django-debug-toolbar* du fichier de *dev-requirements.in* et mettons à jour *dev-requirements.txt*
```shell
(article_pip) [ioo@shikoku ~]$ pip-compile dev-requirements.in
#
# This file is autogenerated by pip-compile
# To update, run:
#
#    pip-compile --output-file dev-requirements.txt dev-requirements.in
#
click==6.6                # via pip-tools
Django==1.9.6
first==2.0.1              # via pip-tools
pip-tools==1.6.5
six==1.10.0               # via pip-tools
```
*pip-sync* fera le travail pour vous et désinstallera le paquet et ses dépendances.
```shell
(article_pip) [ioo@shikoku ~]$ pip-sync
Uninstalling django-debug-toolbar-1.4:
  Successfully uninstalled django-debug-toolbar-1.4
Uninstalling sqlparse-0.1.19:
  Successfully uninstalled sqlparse-0.1.19
```
Vous avez remarqué que *Django* dans le fichier de *dev* est marqué comme dépendance à *django-debug-toolbar*. Mais comme vous l'avez mis dans le fichier de *dev-requirements.in*, en supprimant *django-debub-toolbar*, il reste présent et n'est pas désinstallé. C'est **un effet de bord** mais qui est plus simple à se rappeler qu'une liste des dépendances.

Je vais voir l'usage dans le temps mais j'apprécie l'apport de pip-tools pour maintenir la liste des paquets dans le temps suivant l'environnement.

[^1]: La désinstallation d'un paquet, mais pas de ses dépendances.
